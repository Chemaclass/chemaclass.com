+++
title = "bashunit"
description = "bashunit es un framework de testing ligero para Bash. Testing paralelo, snapshots, dobles de test, data providers y muchas assertions. Nacio de una frustracion y se convirtio en una herramienta open-source."
draft = false
[taxonomies]
tags = [ "bash", "testing", "open-source", "tdd" ]
[extra]
subtitle = "Convirtiendo frustraciones en herramientas para mejor desarrollo"
static_thumbnail = "/images/blog/2024-10-30/cover.jpg"
+++

![blog-cover](/images/blog/2024-10-30/cover.jpg)

bashunit es un framework de testing ligero y facil de usar para Bash. Testing paralelo, snapshots, dobles de test, data providers y muchas assertions.

<!-- more -->

Tiene documentacion clara y una comunidad activa. Nacio de una frustracion de desarrollo y se convirtio en una herramienta open-source que hace el testing en Bash mas facil y divertido.

1. La historia detrás de bashunit
2. ¿Por qué crear otra librería de testing?
3. ¿Cómo está hoy en día?
4. Características principales
5. Lightning tech talk

## La historia detras de bashunit

Todo empezo con una frustracion: en mi equipo, cada commit tenia que empezar con el nombre del ticket. Como me gusta trabajar en pasos pequenos con commits rapidos, anadir la clave del ticket a cada commit se convirtio en un obstaculo. Friccion innecesaria.

Tras unos dias asi, decidi automatizarlo. Git tiene un hook, `prepare-commit-msg`, que permite modificar los mensajes de commit antes de confirmarlos. Cree un [script](https://github.com/Chemaclass/conventional-commits/blob/main/git-hooks/prepare-commit-msg.sh) en Bash que saca la clave del ticket del nombre de la rama y la mete en el mensaje. Proceso mas fluido.

Como me gusta mejorar las cosas, empece a anadir mas funciones al script. Pero mantener y probar cambios a mano era lento y propenso a errores. Asi que cree una funcion `assert` ([enlace](https://github.com/Chemaclass/conventional-commits/blob/705489a3487a4607183090d5574827bf6fedabda/git-hooks/prepare-commit-msg_test.sh)) para tests automatizados que verificaban el comportamiento esperado.

![bashunit-original-assert.jpg](/images/blog/2024-10-30/bashunit-original-assert.jpg)

La funcion `assert` me permitia definir multiples assertions en un archivo separado. Facil de validar que cualquier refactor mantenia el comportamiento esperado. Si un cambio rompia algo, lo sabia al instante. Feedback inmediato. Por ejemplo:

![conventional-commits-original-tests.jpg](/images/blog/2024-10-30/conventional-commits-original-tests.jpg)

En el ejemplo, ejecuto el "`SCRIPT`" real como segundo argumento en assert, comparando su salida con el valor esperado (primer argumento). Hay dos casos de test, cada uno exportando `TEST_BRANCH` para simular como varia el mensaje segun el nombre de la rama. Mas ejemplos [aqui](https://github.com/Chemaclass/conventional-commits/blob/27aeebe4e76afe0a2e91cba85537399eab112eb4/test/prepare-commit-msg_test.sh).

Separe la funcion `assert` de los casos de test ([aqui](https://github.com/Chemaclass/conventional-commits/commit/5458e5728296bb94b1e8e6b25eeccde6cc700589)) para hacerlo modular y reutilizable. Luego cree un `runner` para ejecutar cada test independientemente, reduciendo interferencias y mejorando la fiabilidad. Ver configuracion [aqui](https://github.com/Chemaclass/conventional-commits/commit/92a5880d7f26b3422de6b91b51c04f9ff7b961fd). Testing automatizado mas facil, refactoring mas seguro.

![conventional-commits-call_test_functions.jpg](/images/blog/2024-10-30/conventional-commits-call_test_functions.jpg)

Gran mejora: los [casos de test](https://github.com/Chemaclass/conventional-commits/blob/4c7dae8d44d425ff06fbb48654388f90c2beb3c4/tests/prepare-commit-msg_test.sh) quedaron separados de la logica del runner. Estructura clara que simplifica crear y gestionar tests.

![conventional-commits-refactor-test-cases.jpg](/images/blog/2024-10-30/conventional-commits-refactor-test-cases.jpg)

Ahora los tests estaban organizados y tuve una [idea](https://github.com/Chemaclass/conventional-commits/commit/f459f43cecc271becb1e5eb6ca95d24c97e87830):

![cover](/images/blog/2024-10-30/bashunit-idea.jpg)

```md
## Idea de seguimiento
Separar la lógica de testing en otro repositorio,
para que pueda ser reutilizada en cualquier lugar.
```


Y asi [empezo](https://github.com/TypedDevs/bashunit/commit/27269c21c8d0b03bcb3f2000767f4a27b8bf08a1). Entonces no sabia mucho de Bash ni de como usar un proyecto Bash como dependencia. Empece con un submodulo de Git, aunque no me gustan demasiado.

El 4 de septiembre de 2023 lance la version [0.1](https://github.com/TypedDevs/bashunit/commit/fc9aac40eb8e5ad4483f08d79eb678a3650dcf78): un runner funcional y una unica assertion, `assertEquals`. Luego vino la [0.2](https://github.com/TypedDevs/bashunit/commit/b546c693198870dd75d1a102b94f4ddad6f4f3ea#diff-06572a96a58dc510037d5efa622f9bec8519bc1beab13c9f251e97e657a9d4edR12), que permitia ejecutar `./bashunit` desde cualquier carpeta. Asi se veia:

![bashunit-02-demo.jpg](/images/blog/2024-10-30/bashunit-02-demo.jpg)

Comparti el proyecto con amigos que enseguida se unieron para ayudar con documentacion, web, assertions adicionales, testing de snapshots y decisiones clave. Para remarcar el espiritu open-source, lo movi a una organizacion que creamos para compartir proyectos OSS. Proyecto colaborativo, no individual.

## ¿Por que otra libreria de testing?

Ahora se que hay otras librerias de testing para Bash. Cuando empece bashunit, no las conocia. Y sinceramente, aun no soy experto en Bash. Cuando me entere de las alternativas, ya era tarde: bashunit habia ganado impulso suficiente para seguir.

Esas otras librerias pueden servir casos especificos, usar Bash moderno, o estar hechas por gente con mas experiencia en Bash. bashunit aspira a diferenciarse ofreciendo una gran experiencia de desarrollador, moldeada por anos trabajando con varios frameworks de testing.

Me preguntaron por las diferencias el 7 de septiembre de 2023. Mi respuesta:
[Pregunta: Diferencia con pgrange/bash_unit](https://github.com/TypedDevs/bashunit/issues/8).

## ¿Como esta hoy?

Puedes [instalar](https://bashunit.typeddevs.com/installation) bashunit via curl, Homebrew, MacPorts, descargando el ultimo [release de GitHub](https://github.com/TypedDevs/bashunit/releases), o [compilandolo tu mismo](https://github.com/TypedDevs/bashunit/blob/main/build.sh) desde el codigo fuente. Completamente open-source.

Esta escrito en Bash 3.2 (de 2007), la version por defecto en macOS todavia en 2024. bashunit funciona sin problemas en esa version y planeo mantener el soporte.

Probamos cada feature con tests unitarios, funcionales y de aceptacion. bashunit es su propio "primer usuario" de cada nueva funcion. Tenemos workflows de CI con [GitHub Actions](https://github.com/TypedDevs/bashunit/actions/workflows/tests.yml) que ejecutan tests en diferentes plataformas para verificar compatibilidad.

![bashunit-ci.jpg](/images/blog/2024-10-30/bashunit-ci.jpg)

En junio de 2024, bashunit se [integro en PHPStan](https://bashunit.typeddevs.com/blog/2024-06-21-phpstan-integration) para sus tests end-to-end. Puedes usar las assertions de bashunit sin su runner. Muy util.

El verano pasado me invitaron a hablar sobre bashunit en la [International PHP Conference](/es/talks/#may) en Berlin, junto con [Manu](https://emmanuelvalverde.dev/), otro contribuidor. El proyecto ha abierto puertas y recibido mucho agradecimiento de usuarios.

## Caracteristicas principales

bashunit incluye funciones de ciclo de vida clasicas: `set_up`, `tear_down`, `set_up_before_script` y `tear_down_after_script`.

Soporta muchos [parametros de linea de comandos](https://bashunit.typeddevs.com/command-line) y [valores de configuracion](https://bashunit.typeddevs.com/configuration). Mis favoritos:

* `--parallel`
* `--filter`
* `--stop-on-failure`
* `--verbose`

Tenemos [data providers](https://bashunit.typeddevs.com/data-providers) para ejecutar los mismos tests con diferentes inputs.

Para [dobles de test](https://bashunit.typeddevs.com/test-doubles), bashunit ofrece mocks y spies. Funcionan dentro del mismo proceso que el test, pero no entre procesos (area a mejorar).

Hay [testing de snapshots](https://bashunit.typeddevs.com/snapshots) potente para verificar salidas de comandos o scripts a lo largo del tiempo.

bashunit ofrece muchas [assertions](https://bashunit.typeddevs.com/assertions) nativas:

* `assert_same`
* `assert_equals`
* `assert_contains`
* `assert_matches`
* `assert_string_starts_with`
* `assert_array_contains`
* `assert_successful_code`
* `assert_general_error`
* `assert_file_exists`
* `assert_file_contains`
* `assert_match_snapshot`

Puedes crear tus propias [assertions personalizadas](https://bashunit.typeddevs.com/custom-asserts) para extender bashunit.

Con mas de **25** contribuidores y mas de **325** estrellas en GitHub en solo un ano de desarrollo en tiempo libre, estoy muy orgulloso de lo que ha llegado a ser este proyecto.

## Lightning tech talk

Hace poco presente una lightning talk en un meetup de hackers. Demo de bashunit para mas de 100 personas. Una experiencia genial compartir esta herramienta con una audiencia tan comprometida.

{{ youtube(id="SX7iNHaSsF0") }}

---

Logo original de bashunit diseñado por [Antonio](https://antonio.gg/).
